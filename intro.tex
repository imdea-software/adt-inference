\section{Introduction}
\label{sec:intro}

Many modern software systems rely on efficient implementations of abstract data
types (ADTs) like atomic collections, semaphores, and locks. Efficient
implementation is difficult though, because efficiency entails maximizing
concurrency, and concurrency jeopardizes atomicity. Consequently,
implementations are vulnerable to subtle and elusive bugs compromising
adherence to their ADTs~\cite{journals/cacm/staff11}, thus necessitating
automated verification. Adherence of an implementation to an ADT is captured
formally by a property called \emph{observational refinement}: any observable
behavior over the method call and return actions of the implementation is also
admitted by the the ADT.

Although checking observational refinement is a fundamentally hard
problem\footnote{See Section~\ref{sec:related} for further discussion.} for
arbitrary ADTs~\cite{journals/siamcomp/GibbonsK97, conf/esop/BouajjaniEEH13},
recent work demonstrates that naturally-occurring ADTs like atomic collections,
semaphores, and locks can be checked efficiently given effective symbolic ADT
representations~\cite{conf/popl/BouajjaniEEH15, journals/arxiv/BouajjaniEEH15,
conf/pldi/EmmiEH15}, e.g.,~specified in first-order logic. However, writing
accurate symbolic specifications is an expected challenge for ADT designers. In
practice, ADTs are specified indirectly as the observable behaviors of
possibly-abstract imperative \emph{reference implementations}. Mapping these
reference implementations to logical formulæ describing the same sets of
behaviors is a complex task requiring rare expertise.

In this work we demonstrate that effective symbolic ADT representations can be
generated automatically from the executions of reference implementations. Our
approach exploits two key features of concurrent-object ADTs: that violations
of each ADT can be decomposed into a small set of representative patterns, and
that these patterns manifest in executions with few operations. The first
feature allows us to represent symbolic ADTs finitely, as exclusions of
violation patterns. The second allows us to extract violation patterns from
finite enumerations of executions.

The fundamental challenge is in identifying the algebraic properties of ADTs
which allow us to characterize an infinite set of violating executions with a
finite set of patterns. This characterization is non-trivial since an execution
with more operations than a given violating execution is not necessarily a
violation itself. For instance, an execution which contains only a single {\tt
pop} operation returning the value {\tt 1} is a violation to the atomic stack
ADT, whereas an execution containing an additional {\tt push(1)} operation,
overlapping in time with the {\tt pop}, is not. Further complication arises
from the infinite set of possible data values, i.e.,~method argument and return
values. Our patterns must be sensitive to the \emph{relation} among data values
without being sensitive to the data values themselves. For instance, a
sequential execution in which {\tt 1} and {\tt 2} are pushed and subsequently
popped in the same order violates the atomic stack ADT. Yet, while replacing
both values {\tt 1} and {\tt 2} with the value {\tt 1} results in a
\emph{valid} stack execution, replacing them with {\tt 3} and {\tt 4} results
in a violation.

Our algebraic insight is based on grouping the operations of an execution into
\emph{matchings}. Intuitively, operations which refer to the same instances of
values belong to the same matching. For example, a {\tt pop} operation
returning the value {\tt 1} matches a preceding {\tt push(1)} operation. By
comparing executions by the characteristics of their matchings, rather than the
actual data values they use, we capture the relation among data values
independently of the data values themselves. Furthermore, the notion of
matchings provides a key algebraic property of ADTs: the executions of
naturally-occurring concurrent object ADTs are closed under the removal of
matchings. For example, any execution of the atomic stack ADT using values {\tt
1}, {\tt 2}, and {\tt 3} would remain a valid execution were all operations
using the value {\tt 2} deleted. Conversely, any execution which extends a
violating execution with additional matchings is itself a violation. This
property, along with analogous algebraic properties concerning operation order
and completion, allow us to compare executions via a violation-preserving
embedding relation. This relation is a well-founded partial order on
executions, and thus allows us to characterize the infinite set of violations
to an ADT with a finite basis set, ultimately leading to a finite symbolic
representation.

Computing the basis sets of ADT violation patterns is a challenging problem,
requiring the computation of global properties of an infinite number of
executions — analogously to the inference of inductive invariants. Exploiting a
hypothesis that violation patterns manifest in executions with few operations,
we propose an under-approximating algorithm which extracts the patterns
observed in all violating executions up to a given number of operations. In
theory, for an arbitrary ADT, this is clearly incomplete: any violation which
only surfaces with a greater number of operations would not be captured, thus
resulting in a symbolic ADT representation which can fail to identify
violations — though still guarantees never to classify a valid execution as a
violation. Empirically, however, we demonstrate that our hypothesis holds: the
patterns emerging from executions with few operations are complete in
characterizing all violations of naturally-occurring concurrent object ADTs,
thus allowing us to compute complete symbolic ADT representations in practice.

The contributions and outline of this work are as follows:
\begin{itemize}

  \item The statement of the ADT inference problem (§\ref{sec:inference}).

  \item Identification of algebraic properties allowing finite
  characterizations of infinite ADT violations sets (§\ref{sec:algebra}).

  \item An under-approximating algorithm for the ADT inference problem
  (§\ref{sec:algorithm}).

  \item An algorithm to infer the matching functions required for our algebraic
  characterization of ADTs (§\ref{sec:matching}).

  \item Empirical validation that our ADT-inference approximation is complete
  in practice, and effective for the detection of observational-refinement
  violations~(§\ref{sec:empirical}).

\end{itemize}
We conclude with a discussion of related work (§\ref{sec:related}).
