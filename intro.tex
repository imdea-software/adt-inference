\section{Introduction}
\label{sec:intro}

Many modern software systems rely on efficient implementations of abstract data
types (ADTs) like atomic collections, semaphores, and locks. Efficient
implementation is difficult though, because efficiency entails maximizing
concurrency, and concurrency jeopardizes atomicity. Consequently,
implementations are vulnerable to subtle and elusive bugs compromising
adherence to their ADTs~\cite{journals/cacm/staff11}, thus necessitating
automated verification. Adherence of an implementation to an ADT is captured
formally by a property called \emph{observational refinement}: any observable
behavior over the method call and return actions of the implementation is also
admitted by the the ADT.

Although checking observational refinement is a fundamentally hard
problem\footnote{See Section~\ref{sec:related} for further discussion.} for
arbitrary ADTs~\cite{journals/siamcomp/GibbonsK97, conf/esop/BouajjaniEEH13},
recent work demonstrates that implementations of naturally-occurring ADTs like
atomic collections, semaphores, and locks can be checked efficiently given
effective symbolic ADT representations~\cite{conf/popl/BouajjaniEEH15,
journals/arxiv/BouajjaniEEH15, conf/pldi/EmmiEH15}, e.g.,~specified in
first-order logic. However, writing accurate symbolic specifications is an
expected challenge for ADT designers. In practice, ADTs are specified
indirectly as the observable behaviors of possibly-abstract imperative
\emph{reference implementations}. Mapping these reference implementations to
logical formulæ describing the same sets of behaviors is a complex task
requiring rare expertise.

In this work we demonstrate that effective symbolic ADT representations can be
generated automatically from the executions of reference implementations,
enabling the application of efficient symbolic refinement-checking algorithms
without the burden of writing formal specifications manually. Our approach
exploits two key features of concurrent-object ADTs: that violations of each
ADT can be decomposed into a small set of representative patterns, and that
these patterns manifest in executions with few operations. The first feature
allows us to represent symbolic ADTs finitely, as exclusions of violation
patterns. The second allows us to extract violation patterns from finite
enumerations of executions.

The fundamental challenge is in identifying the algebraic properties of ADTs
which allow us to characterize an infinite set of violating executions with a
finite set of patterns. This characterization is non-trivial since an execution
with more operations than a given violating execution is not necessarily a
violation itself. For instance, an execution which contains only a single
pop operation returning the value $1$ is a violation to the atomic stack
ADT, whereas an execution containing an additional push$(1)$ operation,
overlapping in time with the pop, is not. Further complication arises
from the infinite set of possible data values, i.e.,~method argument and return
values. Our patterns must be sensitive to the \emph{relation} among data values
without being sensitive to the data values themselves. For instance, a
sequential execution in which $1$ and $2$ are pushed and subsequently
popped in the same order violates the atomic stack ADT. Yet, while replacing
both values $1$ and $2$ with the value $1$ results in a
\emph{valid} stack execution, replacing them with $3$ and $4$ results
in a violation.

Our algebraic insight is based on grouping the operations of an execution into
\emph{matchings}. Intuitively, operations which refer to the same instances of
values belong to the same matching. For example, a pop operation
returning the value $1$ matches a preceding push$(1)$ operation. By
comparing executions by the characteristics of their matchings, rather than the
actual data values they use, we capture the relation among data values
independently of the data values themselves. Furthermore, the notion of
matchings provides a key algebraic property of ADTs: the executions of
naturally-occurring concurrent object ADTs are closed under the removal of
matchings. For example, any execution of the atomic stack ADT using values
$1$, $2$, and $3$ would remain a valid execution were all operations
using the value $2$ deleted. Conversely, any execution which extends a
violating execution with additional matchings is itself a violation. This
property, along with analogous algebraic properties concerning operation order
and completion, allow us to compare executions via a violation-preserving
embedding relation. This relation is a well-founded partial order on
executions, and thus allows us to characterize the infinite set of violations
to an ADT with a finite basis set, ultimately leading to a finite symbolic
representation.

Computing the basis sets of ADT violation patterns is a challenging problem,
requiring the computation of global properties of an infinite number of
executions — analogously to the inference of inductive invariants. Exploiting a
hypothesis that violation patterns manifest in executions with few operations,
we propose an under-approximating algorithm which extracts the patterns
observed in all violating executions up to a given number of operations. In
theory, for an arbitrary ADT, this is clearly incomplete: any violation which
only surfaces with a greater number of operations would not be captured, thus
resulting in a symbolic ADT representation which can fail to identify
violations — though still guarantees never to classify a valid execution as a
violation. Empirically, however, we demonstrate that our hypothesis holds: the
patterns emerging from executions with few operations are complete in
characterizing all violations of naturally-occurring concurrent object ADTs,
thus allowing us to compute complete symbolic ADT representations in practice.

Although our approach does require annotating the operations of concurrent
object executions with a matching relation, and we demonstrate that these
relations can be given for naturally-occurring ADTs, we also provide an
automatic means for computing such \emph{matching schemes}. Again by sampling
executions, we leverage automated symbolic reasoning engines to synthesize
matching schemes for which given implementations are closed under the removal
of matches. This further lowers the burden of automated verification. Rather
than providing formal ADT specifications, or even matching schemes, users need
only provide the predicates relevant in the logic of matching schemes, and we
could automatically compute effective matching schemes, and ultimately,
effective symbolic ADT representations.

In summary, the contributions and outline of this work are:
\begin{itemize}

  \item An abstract notion of execution histories based on groups of matching
  operations (§\ref{sec:histories}).

  \item The statement of the ADT inference problem (§\ref{sec:inference}).

  \item Identification of the algebraic properties allowing finite
  characterization and computability of infinite ADT violations sets
  (§\ref{sec:patterns}).

  \item The computability of symbolic ADT representations (§\ref{sec:formula}).

  \item An algorithm to infer the matching schemes required for our algebraic
  characterization of ADTs (§\ref{sec:matching}).

  \item An empirical study validating that naturally-occurring ADTs satisfy the
  properties required for completeness of our inference algorithm, and that our
  algorithm computes precise symbolic representations thereof
  (§\ref{sec:nature}).

\end{itemize}
We conclude with a discussion about the limitations of our approach
(§\ref{sec:discussion}) and related work (§\ref{sec:related}).

To the best of our knowledge, this work is the first to suggest the automatic
generation of symbolic ADT representations for concurrent objects. By removing
the burden of writing formal ADT specifications manually, this work broadens
the scope of efficient symbolic refinement-checking algorithms to
newly-designed ADTs, apart from those few traditionally studied in the
literature.
