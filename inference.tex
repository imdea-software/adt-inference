%!TEX root = draft.tex
\section{The Symbolic ADT Inference Problem}
\label{sec:inference}

In this section we formalize a notion of abstract data type and define the
corresponding refinement and inference problems. These are the foundational
problems addressed in this work.

An \emph{abstract data type (ADT)} $A$ is the set $H(\mathcal{I})$ of histories
of an implementation $\mathcal{I}$. A \emph{kernel} of an ADT $A$ is a minimal
set $H$ of histories generating $A$, i.e.,~such that
\begin{align*}
  A = \set{ h' : \exists h \in H.\ h \to^\ast h' }
\end{align*}
where $\mathord\to = (\to_\mathrm{o} \cup \to_\mathrm{p} \cup \to_\mathrm{c})$.
In Section~\ref{sec:nature} we demonstrate that naturally-occurring ADTs have
unique, bounded-width kernels. For the remainder of this work, we assume ADTs
have unique, bounded-width kernels, denoting \emph{the kernel} of $A$ by $\ker
A$. When $\ker A$ has width $1$, we say $A$ is \emph{atomic}.

We define \emph{observational refinement} between implementations and ADTs as
history-set inclusion. Although this refinement is typically defined with
respect to the admissibility of program executions, recent work demonstrates
that these definitions are equivalent~\cite{conf/popl/BouajjaniEEH15}.

\begin{definition}

  We say an implementation $\mathcal{I}$ \emph{refines} an ADT $A$ when
  $H(\mathcal{I}) \subseteq A$. We say an implementation $\mathcal{I}_1$
  \emph{refines} another implementation $\mathcal{I}_2$ when $\mathcal{I}_1$
  refines $H(\mathcal{I}_2)$.

\end{definition}

Recent works demonstrate efficient algorithms\footnote{In time polynomial in
the number of operations, per execution.} for checking observational
refinement~\cite{conf/popl/BouajjaniEEH15, conf/pldi/EmmiEH15}, yet rely on
hand-written symbolic ADT representations. In order to frame the problem of
computing these automatically, we fix a language for symbolic representation. A
\emph{history formula} is a first-order logic formula with
\begin{itemize}

  \item variables ranging over operation identifiers,

  \item constants from $\mathbb{M}$ for method names,

  \item function symbols ${\sf f}$ and ${\sf m}$ for labels and matching, and

  \item predicate symbols ${\sf c}$, ${\sf um}$, {\sf r}, and ${\sf <}$ for completion,
  non-matching (operations which are not in the domain of the matching function), read-only, and order.

\end{itemize}
A history formula $F$ is interpreted over a history $h$ in the natural way, by
binding variables to the operations of $h$, and binding function and predicate
symbols to their interpretations in $h$. We write $h \models F$ when $h$ is a
model of $F$, and $h \not\models F$ otherwise.

\begin{example}

  The following history formula is satisfied by histories in which no write
  operation happens between a pair of matching write and read operations:
  \begin{align*}
    \forall x_1, x_2, x_3.\
    & {\sf c}(x_1) \land {\sf f}(x_1) = \mathrm{write} \land {\sf m}(x_1) = x_1 \\
    & \land {\sf c}(x_2) \land {\sf f}(x_2) = \mathrm{write} \land {\sf m}(x_2) = x_2 \\
    & \land {\sf c}(x_3) \land {\sf f}(x_3) = \mathrm{read} \land {\sf m}(x_3) = x_1 \\
    & \land x_1 < x_2
      \implies x_3 < x_2
  \end{align*}

  This is one of several requirements of atomic single-value register ADTs,
  which is satisfied by certain linearizations of histories $H(e_2)$ and
  $H(e_3)$ of Example~\ref{ex:histories-of-executions}, yet not $H(e_1)$.

\end{example}

The \emph{bounded complement} of a history set $H$ of width $k \in \mathbb{N} \cup
\set{\omega}$ is the set of histories of width at most $k$ which are excluded
from $H$. Let $A$ be an ADT and $B$ the bounded complement of $\ker A$. We say that
a history formula $F$ \emph{represents} $A$ when
\begin{itemize}

  \item $h \models F$ for all $h \in \ker A$, and

  \item $h \not\models F$ for all $h \in B$.

\end{itemize}
The inference problem is thus to compute a formula representing an ADT.

\begin{definition}

  The \emph{symbolic ADT inference problem} is to compute a history formula
  representing the ADT $H(\mathcal{I})$ of a given implementation $\mathcal{I}$.

\end{definition}
