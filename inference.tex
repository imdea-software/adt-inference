\section{Symbolic ADT Inference}
\label{sec:inference}

TODO MOTIVATE THIS SECTION

We fix an arbitrary infinite set $\mathbb{O}$ of operation identifiers, and
given sets $\mathbb{M}$ and $\mathbb{V}$ of method names and values. A
\emph{call action} binds an operation identifier $o \in \mathbb{O}$ with a
method name $p \in \mathbb{M}$ and argument value $v \in \mathbb{V}$, while a
\emph{return action} binds an operation identifier $o$ with a return value $v$.
An \emph{execution} $e$ is a sequence of call and return actions where
\begin{itemize}

  \item each operation identifier is used in at most one call action, and in at
  most one return action, and

  \item each return action is preceded by a call action with the same operation
  identifier.

\end{itemize}
An \emph{implementation} $\mathcal{I}$ is a prefix-closed set of executions
which is additionally closed under
\begin{itemize}

  \item appending call actions (of fresh operations),

  \item permuting call actions backward in time, and

  \item permuting return actions forward in time.

\end{itemize}
These conditions capture the environment in which implementations execute:
calls are always enabled in their client programs, and thread schedulers may
induce arbitrary delay between implementation code and the associated call and
return actions~\cite{conf/popl/BouajjaniEEH15}.

In this work, histories are abstractions of executions which retain method
names yet ignore argument and return values, and retain the relative order of
operations yet ignore the exact sequence of call and return actions. Formally,
a \emph{history} $h = \tup{O,<,c,f,m}$ is a tuple where
\begin{itemize}

  \item $O \subseteq \mathbb{O}$ is a set of \emph{operations},

  \item $<$ is a partial \emph{happens-before} order on $O$,

  \item $c: O \to \mathbb{B}$ labels operations as \emph{completed}, or not,

  \item $f: O \to \mathbb{M}$ labels operations with method names, and

  \item $m: O \rightharpoonup O$ is a partial \emph{matching} function.

\end{itemize}
Non-completed operations are \emph{pending}, and are maximal in the
happens-before order. The \emph{width} of $h$ is the maximal size of a
subset of $O$ for which each pair of operations is unordered. The \emph{width}
of a history set is the maximal width of its elements. Width-$1$ histories are
\emph{sequential}. An operation $o \in \rng(m)$ is a \emph{match target}, and
the set $\set{ o' \in O : m(o') = o}$ of operations targeting $o$ is a
\emph{match}. We assume targets target themselves: $o \in \set{ o' \in O :
m(o') = o}$.

Our abstraction from executions to histories relies correlating the operations
associated with the same values via matching. A \emph{matching scheme} $M$
associates to each execution $e$ with operations $O$ a partial matching
function $M(e): O \rightharpoonup O$.

\begin{example}

  TODO MATCHING SCHEME EXAMPLE

\end{example}

The history $H(M,e)$ of an execution $e$ under matching scheme $M$ is the tuple
$\tup{O,<,c,f,M(e)}$ where
\begin{itemize}

  \item $O$ are the operations of $e$,

  \item $o_1 < o_2$ if{f} operation $o_1$ returns before $o_2$ is called in $e$,

  \item $c(o)$ if{f} operation $o$ returns in $e$, and

  \item $f(o)$ is the name of the method executed by $o$ in $e$.

\end{itemize}
We denote the set $\set{H(M,e) : e \in E}$ of histories of an execution set $E$
by $H(M,E)$.

A matching scheme $M$ is \emph{faithful} to a set $E$ of executions when $e \in
E$ if{f} $e' \in E$ for any two executions $e$ and $e'$ such that $H(M,e) =
H(M,e')$. A set of executions $E$ is \emph{data independent}\footnote{TODO NOTE
THAT THIS IS NOT THE STANDARD DEFINITIONâ€¦} when there exists a faithful
matching scheme. By definition, abstracting executions to histories comes at no
loss of precision up to set inclusion for data-independent execution sets.

\begin{lemma}

  $H(M,e) \in H(M,E)$ if and only if $e \in E$, for any faithful matching
  scheme $M$.

\end{lemma}

In Section~\ref{sec:nature} we demonstrate faithful matching schemes for the
executions of naturally-occurring concurrent objects, and in
Section~\ref{sec:matching} we demonstrate how to infer faithful matching
schemes. Otherwise, for the remainder of this work, we assume each set of
executions comes equipped with a faithful matching scheme $M$, and abbreviate
$H(M,E)$ by $H(E)$.

Two histories $h_1$ and $h_2$ are related by $\to_x$, for $x = \mathrm{o},
\mathrm{c}, \mathrm{p}$, when $h_2$ is obtained from $h_1$ by:
\begin{itemize}

  \item removing an order constraint (o),

  \item making a completed operation pending (c), or

  \item adding a pending operation (p).

\end{itemize}
A set of histories $H$ is \emph{closed} under a relation $\to$ when $h_2 \in H$
whenever $h_1 \to h_2$ and $h_1 \in H$. A fundamental property of
implementations is that their histories are closed under weakening via less
ordering, fewer operations completed, and additional pending
operations~\cite{conf/popl/BouajjaniEEH15}.

\begin{lemma}

  $H(\mathcal{I})$ is closed under $\to_\mathrm{o}$, $\to_\mathrm{p}$, 
  $\to_\mathrm{c}$.

\end{lemma}

An \emph{abstract data type (ADT)} $A$ is the set $H(\mathcal{I})$ of histories
of an implementation $\mathcal{I}$. A \emph{kernel} of an ADT $A$ is a minimal
set $H$ of histories such that
\begin{align*}
  A = \set{ h' : \exists h \in H.\ h \to^\ast h' }
\end{align*}
where $\to = (\to_\mathrm{o} \cup \to_\mathrm{p} \cup \to_\mathrm{c})$. In
Section~\ref{sec:nature} we demonstrate that naturally-occurring ADTs have
unique kernels. For the remainder of this work, we assume that ADTs have unique
kernels, and denote \emph{the kernel} of $A$ by $\ker A$. We say that $A$ is
\emph{atomic} when the width of $\ker A$ is $1$.

We define \emph{observational refinement} between two implementations, or
between an implementation and an ADT, as history-set inclusion. We say
$\mathcal{I}_1$ \emph{refines} $\mathcal{I}_2$ if{f} $H(\mathcal{I}_1)
\subseteq H(\mathcal{I}_2)$, and $\mathcal{I}$ \emph{refines} $A$ if{f}
$H(\mathcal{I}) \subseteq A$.

In the following we fix a symbolic representation of ADTs on which to base our
symbolic ADT inference problem. A \emph{history formula} $F$ is a first-order
logic formula with
\begin{itemize}

  \item variables ranging over operation identifiers,

  \item constants from $\mathbb{M}$ for method names,

  \item a function symbol $\mathsf{m}$ for matching, and

  \item predicate symbols $\mathsf{c}$ and $\mathsf{<}$ for completion and
  order.

\end{itemize}
A history formula $F$ is interpreted over a history $h$ in the natural way, by
binding variables to the operations of $h$, and binding function and predicate
symbols to their interpretations in $h$. We write $h \models F$ when $h$ is a
model of $F$, and $h \not\models F$ otherwise.

\begin{example}

  TODO HISTORY FORMULA EXAMPLE

\end{example}

The \emph{complement} of an ADT $A$ with width $k \in \mathbb{N}$ is the set of
histories of width at most $k$ which are excluded from $A$. A history formula
$F$ \emph{represents} an ADT $A$ when:
\begin{itemize}

  \item $h \models F$ for all $h \in \ker A$, and

  \item $h \not\models F$ for all $h \in B$,

\end{itemize}
where $B$ is the complement of $\ker A$. The \emph{symbolic ADT inference
problem} is to compute a history formula $F$ representing the ADT of a given
implementation $\mathcal{I}$.
