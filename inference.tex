\section{Symbolic ADT Inference}
\label{sec:inference}

TODO MOTIVATE THIS SECTION

We fix an arbitrary infinite set $\mathbb{O}$ of operation identifiers, and
given sets $\mathbb{M}$ and $\mathbb{V}$ of method names and values. A
\emph{call action} binds an operation identifier $o \in \mathbb{O}$ with a
method name $p \in \mathbb{M}$ and argument value $v \in \mathbb{V}$, while a
\emph{return action} binds an operation identifier $o$ with a return value $v$.
An \emph{execution} $e$ is a sequence of call and return actions where
\begin{itemize}

  \item each operation identifier is used in at most one call action, and in at
  most one return action, and

  \item each return action is preceded by a call action with the same operation
  identifier.

\end{itemize}
A \emph{matching scheme} $M$ associates to each execution $e$ with operations
$O$ a partial matching function $M(e): O \rightharpoonup O$.

\begin{example}

  TODO MATCHING SCHEME EXAMPLE

\end{example}

In this work, histories are abstractions of executions which retain method
names yet ignore argument and return values, and retain the relative order of
operations yet ignore the exact sequence of call and return actions. Formally,
a \emph{history} $h = \tup{O,<,c,f,m}$ is a tuple where
\begin{itemize}

  \item $O \subseteq \mathbb{O}$ is a set of \emph{operations},

  \item $<$ is a partial \emph{happens-before} order on $O$,

  \item $c: O \to \mathbb{B}$ labels operations as \emph{completed}, or not,

  \item $f: O \to \mathbb{M}$ labels operations with method names, and

  \item $m: O \rightharpoonup O$ is a partial \emph{matching} function.

\end{itemize}
Non-completed operations are \emph{pending}, and are maximal in the
happens-before order. The operations of a \emph{sequential} history are totally
ordered. An operation $o \in \rng(m)$ is a \emph{match target}, and the set
$\set{ o' \in O : m(o') = o}$ of operations targeting $o$ is a \emph{match}. We
assume targets target themselves: $o \in \set{ o' \in O : m(o') = o}$.

The history $H(M,e)$ of an execution $e$ under matching scheme $M$ is the tuple
$\tup{O,<,c,f,M(e)}$ where
\begin{itemize}

  \item $O$ are the operations of $e$,

  \item $o_1 < o_2$ if{f} operation $o_1$ returns before $o_2$ is called in $e$,

  \item $c(o)$ if{f} operation $o$ returns in $e$, and

  \item $f(o)$ is the name of the method executed by $o$ in $e$.

\end{itemize}
We denote the set $\set{H(M,e) : e \in E}$ of histories of an execution set $E$
by $H(M,E)$.

A matching scheme $M$ is \emph{faithful} to a set $E$ of executions when $e \in
E$ if{f} $e' \in E$ for any two executions $e$ and $e'$ such that $H(M,e) =
H(M,e')$. A set of executions $E$ is \emph{data independent}\footnote{TODO NOTE
THAT THIS IS NOT THE STANDARD DEFINITIONâ€¦} when there exists a faithful
matching scheme. By definition, abstracting executions to histories comes at no
loss of precision up to set inclusion for data-independent execution sets.

\begin{lemma}

  $H(M,e) \in H(M,E)$ if and only if $e \in E$, for any faithful matching
  scheme $M$.

\end{lemma}

In Section~\ref{sec:nature} we demonstrate faithful matching schemes for the
executions of naturally-occurring concurrent objects, and in
Section~\ref{sec:matching} we demonstrate how to infer faithful matching
schemes. Otherwise, for the remainder of this work, we assume each set of
executions comes equipped with a faithful matching scheme $M$, and abbreviate
$H(M,E)$ by $H(E)$.

An \emph{implementation} $\mathcal{I}$ is a prefixed-closed set of executions.
An \emph{abstract data type (ADT)} $A$ is the set $H(\mathcal{I})$ of histories
of an implementation $\mathcal{I}$. We define \emph{observational refinement}
between two implementations, or between an implementation and an ADT, as
history-set inclusion. We say $\mathcal{I}_1$ \emph{refines} $\mathcal{I}_2$
if{f} $H(\mathcal{I}_1) \subseteq H(\mathcal{I}_2)$, and $\mathcal{I}$
\emph{refines} $A$ if{f} $H(\mathcal{I}) \subseteq A$.

In the following we fix a symbolic representation of ADTs on which to base our
symbolic ADT inference problem. A \emph{history formula} $F$ is a first-order
logic formula with
\begin{itemize}

  \item variables ranging over operation identifiers,

  \item constants from $\mathbb{M}$ for method names,

  \item a function symbol $\mathsf{m}$ for matching, and

  \item predicate symbols $\mathsf{c}$ and $\mathsf{<}$ for completion and
  order.

\end{itemize}
A history formula $F$ is interpreted over a history $h$ in the natural way, by
binding variables to the operations of $h$, and binding function and predicate
symbols to their interpretations in $h$. We write $h \models F$ when $h$ is a
model of $F$, and $h \not\models F$ otherwise.

\begin{example}

  TODO HISTORY FORMULA EXAMPLE

\end{example}

TODO DEFINE KERNEL AND COMPLEMENT

A history formula $F$ \emph{represents} an ADT $A$ when:
\begin{itemize}

  \item $h \models F$ for all $h \in \ker A$, and

  \item $h \not\models F$ for all $h \in B$,

\end{itemize}
where $B$ is the complement of $\ker A$. The \emph{symbolic ADT inference
problem} is to compute a history formula $F$ representing the ADT of a given
implementation $\mathcal{I}$.
