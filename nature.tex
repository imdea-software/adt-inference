\section{Properties of Naturally-Occurring ADTs}
\label{sec:nature}

TODO DEMONSTRATE FAITHFUL MATCHING SCHEMES, UNIQUE AND WIDTH-BOUNDED KERNELS,
NORMALITY, AND PREDICTABILITY FOR EACH NATURALLY-OCCURRING ADT

TODO EXPLAIN “ATOMIC”

\subsection{The Atomic Register}

Atomic register objects implement an atomic single-value store, and provide two
methods:
\begin{itemize}

  \item write$(v)$ stores the value $v$, and

  \item read $\Rightarrow v$ returns the last-stored value $v$, or $\perp$
  if no value has been stored.

\end{itemize}
We say an execution of read and write methods \emph{writes unique values} if
the argument value to each write operation is unique. A faithful matching
scheme is given over the set of executions which write unique values as follows:
\begin{itemize}

  \item write$(v)$ operations match themselves, and

  \item read $\Rightarrow v$ operations are read-only, and match themselves if
  $v = \perp$, or the unique write$(v)$ operation, if one exists, and otherwise 
  have no match.

\end{itemize}
The kernel of atomic registers is the set of sequential histories given by
sequences
\begin{align*}
  \bigcup_{0 \le k \le n < \omega}
  \Big( \underline{\mathrm{read}:i} \Big)_{i=1}^{k}\ 
  \Big( \underline{\mathrm{write}:i}\ (\mathrm{read}:i)^\ast \Big)_{i=k}^{n}
\end{align*}
in which the initial read operations match themselves, write operations match
themselves, and each subsequent read operation matches the nearest preceding
write operation.

TODO ARGUE THAT THIS IS FAITHFUL

It is easy to see that the histories of atomic registers normal. They are
closed under removal of read-only and duplicate operations, since the each
match can contain an arbitrary number of read operations. Since the histories
of atomic registers do not contain unmatched operations, they are also closed
under their removal. Finally, since the kernel contains an arbitrary number of
sequenced matches, atomic register histories are also closed under match
removal.

THIS IS THE SET OF PATTERNS

\begin{verbatim}
  [1:X] read => 1 (RO)  #
  --
  [1:1] write(1)            #
  [2:2] read => empty (RO)    #
  --
  [1:2] read => 1 (RO)  #
  [2:2] write(1)          #
  --
  [1:1] write(1)        #
  [2:2] write(2)          #
  [3:1] read => 1 (RO)      #
\end{verbatim}

The atomic register ADT is predictable \ldots

\subsection{The Atomic Queue}

\begin{verbatim}
  [1:_] remove => 1  #
  --
  [1:1] add(1)                #
  [2:2] remove => empty (RO)    #
  --
  [1:2] remove => 1  #
  [2:2] add(1)         #
  --
  [1:1] add(1)       #
  [2:2] add(2)         #
  [3:2] remove => 2      #
  --
  [1:1] add(1)       #
  [2:1] remove => 1    #
  [3:1] remove => 1      #
  --
  [1:1] add(1)                #
  [2:2] remove => empty (RO)    #
  [3:1] remove => 1               #
  --
  [1:1] add(1)       #
  [2:2] add(2)         #
  [3:2] remove => 2      #
  [4:1] remove => 1        #
\end{verbatim}

\subsection{The Atomic Stack}

\begin{verbatim}
  [1:_] remove => 1  #
  --
  [1:1] add(1)                #
  [2:2] remove => empty (RO)    #
  --
  [1:2] remove => 1  #
  [2:2] add(1)         #
  --
  [1:1] add(1)       #
  [2:2] add(2)         #
  [3:1] remove => 1      #
  --
  [1:1] add(1)       #
  [2:1] remove => 1    #
  [3:1] remove => 1      #
  --
  [1:1] add(1)                #
  [2:2] remove => empty (RO)    #
  [3:1] remove => 1               #
  --
  [1:1] add(1)       #
  [2:2] add(2)         #
  [3:1] remove => 1      #
  [4:2] remove => 2        #
\end{verbatim}

\subsection{The Atomic Set}

\begin{verbatim}
  [1:_] insert(1) => 1 (RO)  #
  --
  [1:_] remove(1) => 1  #
  --
  [1:_] contains(1) => 1 (RO)  #
  --
  [1:1] insert(1) => empty       #
  [2:2] remove(1) => empty (RO)    #
  --
  [1:1] insert(1) => empty         #
  [2:2] contains(1) => empty (RO)    #
  --
  [1:1] insert(1) => empty  #
  [2:1] remove(1) => 1        #
  [3:1] remove(1) => 1          #
  --
  [1:1] insert(1) => empty     #
  [2:1] remove(1) => 1           #
  [3:1] contains(1) => 1 (RO)      #
  --
  [1:1] insert(1) => empty       #
  [2:2] remove(1) => empty (RO)    #
  [3:1] remove(1) => 1               #
  --
  [1:1] insert(1) => empty         #
  [2:2] contains(1) => empty (RO)    #
  [3:1] remove(1) => 1                 #
\end{verbatim}

\subsection{The Atomic Lock}

\begin{verbatim}
  [1:_] lock(1) => 1 (RO)  #
  --
  [1:_] unlock => 1  #
  --
  [1:1] lock(1) => empty  #
  [2:2] lock(2) => empty    #
  --
  [1:1] lock(1) => empty      #
  [2:2] unlock => empty (RO)    #
  --
  [1:1] lock(1) => empty  #
  [2:2] lock(2) => empty    #
  [3:1] unlock => 1           #
  --
  [1:1] lock(1) => empty  #
  [2:2] lock(2) => empty    #
  [3:2] unlock => 2           #
  --
  [1:1] lock(1) => empty   #
  [2:1] unlock => 1          #
  [3:1] lock(2) => 1 (RO)      #
  --
  [1:1] lock(1) => empty  #
  [2:1] unlock => 1         #
  [3:1] unlock => 1           #
  --
  [1:1] lock(1) => empty      #
  [2:2] unlock => empty (RO)    #
  [3:1] unlock => 1               #
  --
  [1:1] lock(1) => empty  #
  [2:2] lock(2) => empty    #
  [3:1] unlock => 1           #
  [4:2] unlock => 2             #
  --
  [1:1] lock(1) => empty  #
  [2:2] lock(2) => empty    #
  [3:2] unlock => 2           #
  [4:1] unlock => 1             #
\end{verbatim}

\subsection{Work-Stealing Queue}

TODO THERE ARE 24 PATTERNS FOR EACH OF THE 4 VARIATIONS

NOTE LIMITATIONS: PRIORITY QUEUE, SEMAPHORE, RENDEZVOUS SYNCHRONIZER,
EXCHANGER, BARRIER, …
