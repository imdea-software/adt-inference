%!TEX root = draft.tex
\section{Properties of Naturally-Occurring ADTs}
\label{sec:nature}

In this section we demonstrate that the premises used in the development of our
symbolic ADT inference algorithm — i.e.,~unique and bounded-width kernels,
faithful and normalizing matching schemes, and predictability — hold for the
ADTs which are typically provided by concurrent object libraries. Furthermore,
we demonstrate that the algorithm developed in this work computes precise
symbolic representations for these ADTs which can be used in symbolic checkers
for observational refinement~\cite{conf/pldi/EmmiEH15}. Our publicly available
implementation\footnote{The URL has been suppressed for anonymity purposes.}
enumerates the sequential histories\footnote{Our current implementation is
limited to atomic ADTs. For non-atomic ADTs, the enumeration must cover all
$k$-width histories, for some $k \in \mathbb{N}$.} not admitted by reference
implementations of the undermentioned ADTs, keeping only the histories which
are not generated by any other. In each case, our algorithm terminates in a
matter of seconds.

\subsection{The Atomic Register}

The atomic register implements an atomic single-value store, providing two
methods:
\begin{itemize}

  \item write$(v)$ stores the value $v$, and

  \item read $\Rightarrow v$ returns the last-stored value $v$, or the nil
  value $-$ if no value has yet been stored.

\end{itemize}
As its name implies, its kernel is sequential.

We say an execution of read and write methods \emph{writes unique values} if
the argument value to each write operation is unique. A faithful matching
scheme is given over the set of executions which write unique values as follows:
\begin{itemize}

  \item write$(v)$ operations match themselves, and

  \item read $\Rightarrow v$ operations are read-only, and match themselves if
  $v = -$, or the unique write$(v)$ operation, if one exists, and otherwise 
  have no match.

\end{itemize}
This matching scheme is faithful since two executions with the same history
are identical up to homomorphic renaming of data values, and the register ADT
only relates data values via equality.

It is easy to see that the atomic register is normal. It is
closed under removal of read-only and duplicate operations, since  each
match can contain an arbitrary number of read operations. Since the histories
of atomic registers do not contain unmatched operations, they are also closed
under their removal. Finally, since the kernel contains an arbitrary number of
sequenced matches, atomic register histories are also closed under match
removal.

Our inference algorithm computes the following four histories to generate the
complement of the atomic register ADT:
\begin{verbatim}
  [1:X] read => 1 (RO)  #        [1:1] write(1)        #
  ---                            [2:2] read => - (RO)    #
  [1:1] write(1)        #        ---
  [2:2] write(2)          #      [1:2] read => 1 (RO)  #
  [3:1] read => 1 (RO)      #    [2:2] write(1)          #
\end{verbatim}
As new generators are discovered for $n=1$ and $n=2$ matches only, the atomic
register ADT is predictable.

\subsection{The Atomic Queue \& The Atomic Stack}

Atomic queues and stacks implement atomic collections of data values with
first-in-first-out (FIFO) and last-in-first-out (LIFO) removal order,
respectively, providing two methods:\footnote{These methods are also known as
enqueue and dequeue, or push and pop.}
\begin{itemize}

  \item add$(v)$ adds the value $v$ to the collection, and

  \item remove $\Rightarrow v$ returns the nil value $v = -$ if the
  collection is empty, and otherwise removes and returns the least- or
  most-recently added value $v$, respectively.

\end{itemize}
As their names imply, their kernels are sequential.

An execution \emph{adds unique values} if the argument value to each add
operation is unique. We give a faithful matching scheme over executions which
add unique values as follows:
\begin{itemize}

  \item add$(v)$ operations match themselves, and

  \item remove $\Rightarrow v$ operations are read-only, and match themselves
  if $v = -$ is the nil value. If $v \neq -$, remove
  $\Rightarrow v$ operations are not read-only, and match the unique add$(v)$
  operation, if one exists, and otherwise have no match.

\end{itemize}
This matching scheme is faithful since two executions with the same history are
identical up to homomorphic renaming of data values, and the queue and stack
ADTs only relate data values via equality.

It is not hard to see that the atomic queues and stacks are
normal. They are closed under removal of read-only operations: only empty
removes, i.e.,~remove $\Rightarrow -$, are read-only. They are
closed under the removal of duplicate operations: only non-empty removes can be
duplicates, and such duplicates are not admitted in the first place, since each
value is added only once. Similarly, unmatched operations, i.e.,~removes that
return values that have not been added, are not admitted in the first place.
Finally, since the removal of entire matches preserves the FIFO/LIFO behavior
of the entire collection, and the correctness of empty returns, histories are
also closed under match removal.

We compute the following seven histories to generate the complement of the
atomic queue ADT:
\begin{verbatim}
  [1:X] remove => 1  #           [1:1] add(1)       #
  ---                            [2:1] remove => 1    #
  [1:1] add(1)            #      [3:1] remove => 1      #
  [2:2] remove => - (RO)    #    ---
  ---                            [1:1] add(1)            #
  [1:2] remove => 1  #           [2:2] remove => - (RO)    #
  [2:2] add(1)         #         [3:1] remove => 1           #
  ---                            ---
  [1:1] add(1)       #           [1:1] add(1)       #
  [2:2] add(2)         #         [2:2] add(2)         #
  [3:2] remove => 2      #       [3:2] remove => 2      #
                                 [4:1] remove => 1        #
\end{verbatim}
The histories computed for the atomic stack ADT are nearly identical,
substituting only the bottom two histories for the following:
\begin{verbatim}
  [1:1] add(1)       #           [1:1] add(1)       #
  [2:2] add(2)         #         [2:2] add(2)         #
  [3:1] remove => 1      #       [3:1] remove => 1      #
                                 [4:2] remove => 2        #
\end{verbatim}
As new generators are discovered for $n=1$ and $n=2$ matches only, these ADTs
are predictable.

\subsection{The Atomic Set}

Atomic sets implement collections which store one copy of each inserted data
value no matter how many times the same value is inserted, until removed,
providing three methods:
\begin{itemize}

  \item insert$(u) \Rightarrow v$ inserts the value $u$ to the collection,

  \item remove$(u) \Rightarrow v$ removes $u$ from the collection, and

  \item contains$(u) \Rightarrow v$ checks whether the set contains $u$.

\end{itemize}
Each operation returns the nil value $v = -$ when $u$ is not yet
present, and otherwise returns $v = u$. As its name implies, its kernel is
sequential.

An execution \emph{inserts unique values} if the argument value to each insert
operation which returns $-$ is unique. We give a faithful matching
scheme over executions which insert unique values as follows:
\begin{itemize}

  \item any operation returning $v = -$ matches itself, and

  \item any operation returning $v \neq -$ matches the unique
  insert$(v) \Rightarrow -$ operation, if one exists, and otherwise
  has no match.

\end{itemize}
This matching scheme is faithful since two executions with the same history are
identical up to homomorphic renaming of data values, and sets only relates data
values via equality.

We compute the following nine histories to generate the complement of the
atomic set ADT:
\begin{verbatim}
  [1:X] insert(1) => 1 (RO)  #        [1:1] insert(1) => -  #
  ---                                 [2:1] remove(1) => 1    #
  [1:X] remove(1) => 1  #             [3:1] remove(1) => 1      #
  ---                                 ---
  [1:X] contains(1) => 1 (RO)  #      [1:1] insert(1) => -         #
  ---                                 [2:1] remove(1) => 1           #
  [1:1] insert(1) => -       #        [3:1] contains(1) => 1 (RO)      #
  [2:2] remove(1) => - (RO)    #      ---
  ---                                 [1:1] insert(1) => -       #
  [1:1] insert(1) => -         #      [2:2] remove(1) => - (RO)    #
  [2:2] contains(1) => - (RO)    #    [3:1] remove(1) => 1           #
\end{verbatim}
As new generators are discovered for $n=1$ and $n=2$ matches only, the atomic
set ADT is predictable.

\subsection{The Atomic Lock}

Atomic locks implement resource-based mutual exclusion by providing two
methods
\begin{itemize}

  \item lock$(u) \Rightarrow v$ acquires the lock resource,

  \item unlock $\Rightarrow v$ releases the lock resource.

\end{itemize}
An operation returns the nil value $v = -$ when the lock is not
currently held, indicating success for lock, and failure for unlock. Otherwise,
the operations return the value $u = v$ passed as an argument to the last
successful lock$(u)$ operation.

An execution \emph{uses unique keys} if the argument value to each lock
operation is unique. We give a faithful matching scheme over executions using
unique keys as follows:
\begin{itemize}

  \item any operation returning $v = -$ matches itself, and

  \item any operation returning $v \neq -$ matches the unique
  lock$(v) \Rightarrow -$ operation, if one exists, and otherwise
  has no match.

\end{itemize}
It is easy to see that this matching scheme is faithful, and normalizing.

We compute the following eleven histories to generate the complement of the
atomic lock ADT:
\begin{verbatim}
  [1:X] unlock => 1  #             [1:X] lock(1) => 1 (RO)  #
  ---                              ---
  [1:1] lock(1) => -  #            [1:1] lock(1) => -  #
  [2:2] lock(2) => -    #          [2:1] unlock => 1     #
  ---                              [3:1] unlock => 1       #
  [1:1] lock(1) => -      #        ---
  [2:2] unlock => - (RO)    #      [1:1] lock(1) => -      #
  ---                              [2:2] unlock => - (RO)    #
  [1:1] lock(1) => -  #            [3:1] unlock => 1           #
  [2:2] lock(2) => -    #          ---
  [3:1] unlock => 1       #        [1:1] lock(1) => -  #
  ---                              [2:2] lock(2) => -    #
  [1:1] lock(1) => -  #            [3:1] unlock => 1       #
  [2:2] lock(2) => -    #          [4:2] unlock => 2         #
  [3:2] unlock => 2       #        ---
  ---                              [1:1] lock(1) => -  #
  [1:1] lock(1) => -       #       [2:2] lock(2) => -    #
  [2:1] unlock => 1          #     [3:2] unlock => 2       #
  [3:1] lock(2) => 1 (RO)      #   [4:1] unlock => 1         #
\end{verbatim}
As new generators are discovered for $n=1$ and $n=2$ matches only, the atomic
lock ADT is predictable.

\subsection{Work-Stealing Queue}

The work-stealing queue~\cite{journals/dc/HendlerLMS06} implements a collection
of data values with first-in-first-out\footnote{There are actually four
variations to the work-stealing queue, depending on the ends from which the
take and steal operations remove values. While our approach works
indifferently, below we focus on the variation where both remove the least
recent.} (FIFO) removal order, proving three methods:
\begin{itemize}

  \item give$(v)$ adds the value $v$ to the queue,

  \item take $\Rightarrow v$ removes the value $v$, and

  \item steal $\Rightarrow v$ removes the value $v$.

\end{itemize}
Unlike atomic queues, the work-stealing queue permits values to be removed
twice: once normally, via the take operation, and once exceptionally, via the
steal operation. We give a faithful matching scheme over executions which add
unique values analogously to the scheme for stacks and queues, in which give
operations match themselves, while take and steal operations match the give
operation which added their returned value, or themselves, in case the nil
value is returned. Note that the kernel of work-stealing queues has width $2$,
since a pairs of concurrent take and steal operations returning the same value
are permitted, while sequentially they are not. As our implementation is
currently limited to width-$1$ histories (see the discussion in
Section~\ref{sec:discussion}), below we generate only the width-$1$ complement.

We compute the following twenty-four histories to generate the complement of
the work-stealing queue ADT:
\begin{verbatim}
  [1:_] take => 1  #             [1:_] steal => 1  #
  ---                            ---
  [1:1] give(1)         #        [1:1] give(1)          #
  [2:2] take => - (RO)    #      [2:2] steal => - (RO)    #
  ---                            ---
  [1:2] take => 1  #             [1:2] steal => 1  #
  [2:2] give(1)      #           [2:2] give(1)       #
  ---                            ---
  [1:1] give(1)    #             [1:1] give(1)     #
  [2:2] give(2)      #           [2:2] give(2)       #
  [3:2] take => 2      #         [3:2] steal => 2      #
  ---                            ---
  [1:1] give(1)    #             [1:1] give(1)     #
  [2:1] take => 1    #           [2:1] take => 1     #
  [3:1] take => 1      #         [3:1] steal => 1      #
  ---                            ---
  [1:1] give(1)         #        [1:1] give(1)         #
  [2:2] take => - (RO)    #      [2:2] take => - (RO)    #
  [3:1] take => 1           #    [3:1] steal => 1          #
  ---                            ---
  [1:1] give(1)     #            [1:1] give(1)     #
  [2:1] steal => 1    #          [2:1] steal => 1    #
  [3:1] take => 1       #        [3:1] steal => 1      #
  ---                            ---
  [1:1] give(1)          #       [1:1] give(1)          #
  [2:2] steal => - (RO)    #     [2:2] steal => - (RO)    #
  [3:1] take => 1            #   [3:1] steal => 1           #
  ---                            ---
  [1:2] take => 1   #            [1:3] take => 1   #
  [2:2] give(1)       #          [2:3] steal => 1    #
  [3:2] steal => 1      #        [3:3] give(1)         #
  ---                            ---
  [1:2] steal => 1  #            [1:3] steal => 1  #
  [2:2] give(1)       #          [2:3] take => 1     #
  [3:2] take => 1       #        [3:3] give(1)         #
  ---                            ---
  [1:1] give(1)    #             [1:1] give(1)     #
  [2:2] give(2)      #           [2:2] give(2)       #
  [3:2] take => 2      #         [3:2] take => 2       #
  [4:1] take => 1        #       [4:1] steal => 1        #
  ---                            ---
  [1:1] give(1)     #            [1:1] give(1)     #
  [2:2] give(2)       #          [2:2] give(2)       #
  [3:2] steal => 2      #        [3:2] steal => 2      #
  [4:1] take => 1         #      [4:1] steal => 1        #
\end{verbatim}
As new generators are discovered for $n=1$ and $n=2$ matches only, the
work-stealing queue ADT is predictable.
