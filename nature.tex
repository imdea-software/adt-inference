\section{Properties of Naturally-Occurring ADTs}
\label{sec:nature}

In this section we demonstrate that the premises used in the development of our
symbolic ADT inference algorithm — i.e.,~unique and bounded-width kernels,
faithful and normalizing matching schemes, and predictability — hold for the
ADTs which are typically provided by concurrent object libraries. Furthermore,
we demonstrate that the algorithm developed in this work computes precise
symbolic representations for these ADTs which can be used in symbolic checkers
for observational refinement~\cite{conf/pldi/EmmiEH15}. Our publicly available
implementation\footnote{The URL has been suppressed for anonymity purposes.}
enumerates the sequential histories\footnote{Our current implementation is
limited to atomic ADTs. For non-atomic ADTs, the enumeration must cover all
$k$-width histories, for some $k \in \mathbb{N}$.} not admitted by reference
implementations of the undermentioned ADTs, keeping only the histories which
are not generated by any other. In each case, our algorithm terminates in a
matter of seconds.

\subsection{The Atomic Register}

Atomic register objects implement an atomic single-value store, and provide two
methods:
\begin{itemize}

  \item write$(v)$ stores the value $v$, and

  \item read $\Rightarrow v$ returns the last-stored value $v$, or $\perp$
  if no value has yet been stored.

\end{itemize}
Its kernel is sequential.

We say an execution of read and write methods \emph{writes unique values} if
the argument value to each write operation is unique. A faithful matching
scheme is given over the set of executions which write unique values as follows:
\begin{itemize}

  \item write$(v)$ operations match themselves, and

  \item read $\Rightarrow v$ operations are read-only, and match themselves if
  $v = \perp$, or the unique write$(v)$ operation, if one exists, and otherwise 
  have no match.

\end{itemize}

TODO ARGUE THAT THIS IS FAITHFUL

It is easy to see that the histories of atomic registers normal. They are
closed under removal of read-only and duplicate operations, since the each
match can contain an arbitrary number of read operations. Since the histories
of atomic registers do not contain unmatched operations, they are also closed
under their removal. Finally, since the kernel contains an arbitrary number of
sequenced matches, atomic register histories are also closed under match
removal.

Our inference algorithm computes following set of histories to generate the
complement of the atomic register ADT:
\begin{verbatim}
  [1:X] read => 1 (RO)  #
  --
  [1:1] write(1)            #
  [2:2] read => empty (RO)    #
  --
  [1:2] read => 1 (RO)  #
  [2:2] write(1)          #
  --
  [1:1] write(1)        #
  [2:2] write(2)          #
  [3:1] read => 1 (RO)      #
\end{verbatim}
As new basis histories are generated for $n=1$, $n=2$, and $n=3$ matches, the
atomic register ADT is predictable.

\subsection{The Atomic Queue}

\begin{verbatim}
  [1:_] remove => 1  #
  --
  [1:1] add(1)                #
  [2:2] remove => empty (RO)    #
  --
  [1:2] remove => 1  #
  [2:2] add(1)         #
  --
  [1:1] add(1)       #
  [2:2] add(2)         #
  [3:2] remove => 2      #
  --
  [1:1] add(1)       #
  [2:1] remove => 1    #
  [3:1] remove => 1      #
  --
  [1:1] add(1)                #
  [2:2] remove => empty (RO)    #
  [3:1] remove => 1               #
  --
  [1:1] add(1)       #
  [2:2] add(2)         #
  [3:2] remove => 2      #
  [4:1] remove => 1        #
\end{verbatim}

\subsection{The Atomic Stack}

\begin{verbatim}
  [1:_] remove => 1  #
  --
  [1:1] add(1)                #
  [2:2] remove => empty (RO)    #
  --
  [1:2] remove => 1  #
  [2:2] add(1)         #
  --
  [1:1] add(1)       #
  [2:2] add(2)         #
  [3:1] remove => 1      #
  --
  [1:1] add(1)       #
  [2:1] remove => 1    #
  [3:1] remove => 1      #
  --
  [1:1] add(1)                #
  [2:2] remove => empty (RO)    #
  [3:1] remove => 1               #
  --
  [1:1] add(1)       #
  [2:2] add(2)         #
  [3:1] remove => 1      #
  [4:2] remove => 2        #
\end{verbatim}

\subsection{The Atomic Set}

\begin{verbatim}
  [1:_] insert(1) => 1 (RO)  #
  --
  [1:_] remove(1) => 1  #
  --
  [1:_] contains(1) => 1 (RO)  #
  --
  [1:1] insert(1) => empty       #
  [2:2] remove(1) => empty (RO)    #
  --
  [1:1] insert(1) => empty         #
  [2:2] contains(1) => empty (RO)    #
  --
  [1:1] insert(1) => empty  #
  [2:1] remove(1) => 1        #
  [3:1] remove(1) => 1          #
  --
  [1:1] insert(1) => empty     #
  [2:1] remove(1) => 1           #
  [3:1] contains(1) => 1 (RO)      #
  --
  [1:1] insert(1) => empty       #
  [2:2] remove(1) => empty (RO)    #
  [3:1] remove(1) => 1               #
  --
  [1:1] insert(1) => empty         #
  [2:2] contains(1) => empty (RO)    #
  [3:1] remove(1) => 1                 #
\end{verbatim}

\subsection{The Atomic Lock}

\begin{verbatim}
  [1:_] lock(1) => 1 (RO)  #
  --
  [1:_] unlock => 1  #
  --
  [1:1] lock(1) => empty  #
  [2:2] lock(2) => empty    #
  --
  [1:1] lock(1) => empty      #
  [2:2] unlock => empty (RO)    #
  --
  [1:1] lock(1) => empty  #
  [2:2] lock(2) => empty    #
  [3:1] unlock => 1           #
  --
  [1:1] lock(1) => empty  #
  [2:2] lock(2) => empty    #
  [3:2] unlock => 2           #
  --
  [1:1] lock(1) => empty   #
  [2:1] unlock => 1          #
  [3:1] lock(2) => 1 (RO)      #
  --
  [1:1] lock(1) => empty  #
  [2:1] unlock => 1         #
  [3:1] unlock => 1           #
  --
  [1:1] lock(1) => empty      #
  [2:2] unlock => empty (RO)    #
  [3:1] unlock => 1               #
  --
  [1:1] lock(1) => empty  #
  [2:2] lock(2) => empty    #
  [3:1] unlock => 1           #
  [4:2] unlock => 2             #
  --
  [1:1] lock(1) => empty  #
  [2:2] lock(2) => empty    #
  [3:2] unlock => 2           #
  [4:1] unlock => 1             #
\end{verbatim}

\subsection{Work-Stealing Queue}

TODO THERE ARE 24 PATTERNS FOR EACH OF THE 4 VARIATIONS
