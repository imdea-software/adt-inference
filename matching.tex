\section{Computing Matching Schemes}
\label{sec:matching}

TODO MOTIVATE THIS SECTION

A \emph{language} $L = \tup{E,P,Q}$ is a set $E$ of executions, along with
finite sequences $P = P_1 P_2 \ldots$ and $Q = Q_1 Q_2 \ldots$ of binary and
ternary predicates $P_i(e,o_1)$ and $Q_i(e,o_1,o_2)$ ranging over the
executions of $E$ and their operations. When $P$ is a $k$-length sequence of
$n$-ary predicates, we write $P(x_1, \ldots, x_n)$ to denote the valuation
sequence
\begin{align*}
  P_1(x_1, \ldots, x_n) \ldots P_k(x_1, \ldots, x_n).
\end{align*}
Given a language $L = \tup{E,P,Q}$, we say a matching scheme $M$ is
\emph{simple} when there exists an $n$-ary Boolean function $G$, for $n =
2\cdot|P|+|Q|$, such that for each execution $e \in E$
\begin{itemize}

  \item $G(P(e,o_1),P(e,o_2),Q(e,o_1,o_2))$ is satisfied for at most one
  operation $o_1$, for any operation $o_2$,

  \item $M(e)(o_2)$ is undefined unless there exists an operation $o_1$
  for which $G(P(e,o_1),P(e,o_2),Q(e,o_1,o_2))$, and

  \item $M(e)(o_2) = o_1$ if{f} $G(P(e,o_1),P(e,o_2),P(e,o_1,o_2))$,

\end{itemize}
where $o_1$ and $o_2$ range over the operations of $e$.

\begin{example}

  We say an execution of read and write methods \emph{writes unique values} if
  the argument value to each write operation is unique. Consider the language
  whose executions write unique values, with the following predicates:
  \begin{align*}
    & \mathsf{write}(e,o) & \text{$o$ is a {\sf write} operation in $e$}, \\
    & \mathsf{read}(e,o) & \text{$o$ is a {\sf read} operation in $e$,} \\
    & \mathsf{eq}(e,o_1,o_2) & \text{$o_1$ and $o_2$ are the same operation, and} \\
    & \mathsf{veq}(e,o_1,o_2) & \text{$o_1$ and $o_2$ read/write the same values.}
  \end{align*}
  Given a valuation $\tup{x_\mathsf{w}, x_\mathsf{r}, y_\mathsf{w},
  y_\mathsf{r}, z_\mathsf{=}, z_\mathsf{v}}$ of the predicates above, we define
  the function $G(x_\mathsf{w}, x_\mathsf{r}, y_\mathsf{w}, y_\mathsf{r},
  z_\mathsf{=}, z_\mathsf{v})$ to be satisfied if and only if:
  \begin{align*}
    ( x_\mathsf{w} \land z_\mathsf{=} )
    \lor ( x_\mathsf{w} \land y_\mathsf{r} \land z_\mathsf{v} )
  \end{align*}
  Intuitively, this defines a simple matching scheme for which write
  operations match themselves, and read operations match the write which wrote
  the value read. In the case such a write exists, it is unique in any
  execution which writes unique values. The match is otherwise undefined.

\end{example}

An implementation $\mathcal{I}$ \emph{adheres} to a language $L = \tup{E,P,Q}$
if $\mathcal{I} \subseteq E$. A match scheme $M$ \emph{normalizes} an
implementation $\mathcal{I}$ when $M$ is faithful to $\mathcal{I}$ and
$H(\mathcal{I},M)$ is normal.

\begin{example}

  TODO SHOW THAT PREVIOUS SIMPLE MATCHING SCHEME NORMALIZES SOMETHING

\end{example}

\begin{definition}

  The \emph{matching scheme inference problem} is to compute a simple matching
  scheme $M$ which normalizes a given implementation $\mathcal{I}$ adhering to
  a given language $L$.

\end{definition}

TODO ARGUE THAT SIMPLE NORMALIZING MATCHING SCHEMES CAN BE
COMPUTED/APPROXIMATED BY CHECKING WHETHER FINITE SETS OF EXECUTIONS AND THEIR
PROJECTIONS ARE MATCH-REMOVAL CLOSED

$\textsc{IsMatch}_{e,O}$:
\begin{align*}
  \bigvee_{o_1 \in O} \bigwedge_{o_2 \in O}
  \mathsf{g}(P(e,o_1), P(e,o_2), Q(e,o_1,o_2))
\end{align*}
represents whether $O$ is a match of $e$ according to the simple matching
scheme generated by $\mathsf{g}$, and
\begin{align*}
  \bigwedge_{\tup{e,O}\in \_} \lnot \textsc{IsMatch}_{e,O}
\end{align*}
insists that for any execution $e \in \mathcal{I}$ whose projection to
operations not in $O$ is not in $\mathcal{I}$, then $O$ must not be a match.

ENUMERATE LOTS OF EXECUTION PAIRS $\tup{e,e'}$ FOR WHICH $e'$ IS A PROJECTION
OF $e'$ WITH $e \in \mathcal{I}$ AND $e' \not\in \mathcal{I}$, AND LET $O$ BE
THE OPERATIONS IN $e$ BUT NOT $e'$. HOPEFULLY IF THIS FORMULA IS SATISFIABLE, A
MODEL FOR {\sf g} CAN BE A GOOD SIMPLE MATCHING SCHEME

\begin{theorem}

  The matching scheme inference problem is computable for \ldots

\end{theorem}
