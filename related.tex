\section{Related Work}
\label{sec:related}

Inference of symbolic abstract data types is a recently-pertinent problem
arising from the emergence of efficient symbolic refinement-checking
algorithms~\cite{conf/popl/BouajjaniEEH15, conf/pldi/EmmiEH15} which require
symbolic, logical representations of ADT specifications. Though approaches
based on the explicit enumeration of execution
linearizations~\cite{journals/jpdc/WingG93, conf/pldi/BurckhardtDMT10,
conf/asplos/BurnimNS11, conf/kbse/ZhangCW13} do not require symbolic ADT
representations, and work directly with given reference implementations, these
approaches are intractable as they elaborate an exponential\footnote{The number
of possible linarizations is exponential in execution length.} number of
linearizations.

Other approaches to tractable refinement-checking are based on annotating
method bodies with \emph{linearization
points}~\cite{journals/toplas/HerlihyW90, conf/cav/AmitRRSY07,
conf/fm/LiuCLS09, conf/cav/Vafeiadis10, conf/podc/OHearnRVYY10,
conf/icse/Zhang11a, conf/oopsla/ShachamBASVY11, conf/cav/DragoiGH13,
conf/pldi/LiangF13} to reduce the otherwise exponential number of possible
linearizations to one single linearization. This approach, however, does not
apply to all implementations~\cite{journals/toplas/HerlihyW90}, and
applications of this approach often rely on manual annotation of the
implementation source code. Furthermore, this approach does not admit
conclusive evidence of a refinement violation in case of failure.

The idea of inferring minimal finite representations of otherwise-infinite sets
of implementation behaviors has also been proposed as an optimization to reduce
the impact of state-space explosion in compositional
verification~\cite{journals/ase/GiannakopoulouPB05}. This approach is based on
learning minimal automata for regular languages, and requires the
implementation of both language membership and equivalence
queries~\cite{journals/iandc/Angluin87}. In our setting, it is unclear whether
ADT implementations may admit regular characterizations in general, and
furthermore how to automatically discharge language equivalence queries between
candidate automata and the source code of reference implementations.

The idea of decomposing ADT violations into a finite set of patterns has been
proposed for atomic collections~\cite{conf/tacas/AbdullaHHJR13,
conf/concur/HenzingerSV13, conf/popl/DoddsHK15, conf/popl/BouajjaniEEH15}, and
generalized to ADTs which can be expressed with a particular form of recursive
definition~\cite{conf/icalp/BouajjaniEEH15}. These works suggest patterns
which directly recognize violations in \emph{concurrent} executions,
effectively reducing observational refinement to the verification of classical
temporal-logic properties. Some of these patterns are expressible only as
\emph{infinite}, though regular, languages. On the contrary, in this work we
suggest patterns expressed as \emph{finite} languages, which recognize
violations in ADTs — i.e.,~the sequential executions of atomic
objects, or the “concurrency-aware” executions of “concurrency-aware”
specifications~\cite{conf/podc/HemedR14}. Though by themselves these patterns
are incomplete in recognizing violations in concurrent executions, they are
complete when considered as negative conditions on the linearizations of
concurrent executions, effectively reducing verification of a single execution
to satisfiability checking~\cite{conf/pldi/EmmiEH15}.
